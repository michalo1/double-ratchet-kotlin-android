<html>
<head>
<title>DoubleRatchet.kt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(0,0,128); font-weight: bold; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(128,128,128); font-style: italic; }
.s3 { color: rgb(128,128,128); font-weight: bold; font-style: italic; }
.s4 { color: rgb(0,0,255); }
.s5 { color: rgb(0,128,0); font-weight: bold; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
DoubleRatchet.kt</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">package </span><span class="s1">sk.ozaniak.doubleratchet 
 
import org.spongycastle.crypto.BlockCipher 
import org.spongycastle.crypto.digests.SHA512Digest 
import org.spongycastle.crypto.engines.AESEngine 
import org.spongycastle.crypto.generators.HKDFBytesGenerator 
import org.spongycastle.crypto.macs.HMac 
import org.spongycastle.crypto.modes.AEADBlockCipher 
import org.spongycastle.crypto.modes.GCMBlockCipher 
import org.spongycastle.crypto.params.AEADParameters 
import org.spongycastle.crypto.params.HKDFParameters 
import org.spongycastle.crypto.params.KeyParameter 
import org.whispersystems.curve25519.Curve25519 
import org.whispersystems.curve25519.Curve25519KeyPair 
 
</span><span class="s2">/**</span><span class="s1"> 
 </span><span class="s2">* Implementation of Double Ratchet algorithm according to implementation guidelines from:</span><span class="s1"> 
 </span><span class="s2">* https://signal.org/docs/specifications/doubleratchet/#double-ratchet-1</span><span class="s1"> 
 </span><span class="s2">*</span><span class="s1"> 
 </span><span class="s2">* </span><span class="s3">@author </span><span class="s2">Michal Ozaniak</span><span class="s1"> 
 </span><span class="s2">* </span><span class="s3">@version </span><span class="s2">0.1</span><span class="s1"> 
 </span><span class="s2">*/</span><span class="s1"> 
</span><span class="s0">class </span><span class="s1">DoubleRatchet private constructor(</span><span class="s0">val </span><span class="s1">appSpecificInfo: ByteArray, 
                                        </span><span class="s0">val </span><span class="s1">maxSkip: Int, 
                                        </span><span class="s0">val </span><span class="s1">cryptoEngine: BlockCipher, 
                                        </span><span class="s0">val </span><span class="s1">AEADBlockCipher: AEADBlockCipher, 
                                        </span><span class="s0">val </span><span class="s1">fixedNonce: ByteArray, 
                                        </span><span class="s0">val </span><span class="s1">macSize: Int, 
                                        </span><span class="s0">val </span><span class="s1">keyPairGenerator: DoubleRatchetKeyPairGenerator) { 
 
    private constructor(builder: Builder) : </span><span class="s0">this</span><span class="s1">( 
            builder.appSpecificInfo, </span><span class="s2">// Optional HKDF info parameter. Random app specific byte array</span><span class="s1"> 
            builder.maxSkip, </span><span class="s2">// Max number of skipped messages in a chain</span><span class="s1"> 
            builder.cryptoEngine, </span><span class="s2">// Engine that defines used encryption specification for messages</span><span class="s1"> 
            builder.AEADBlockCipher, </span><span class="s2">// Specifies AEAD mode of operation such as CCM, EAX, GCM,...</span><span class="s1"> 
            builder.fixedNonce, </span><span class="s2">// A nonce used for encryption. Can be fixed because each message key is used only once.</span><span class="s1"> 
            builder.macSize, </span><span class="s2">// Size of MAC used for AEAD in bits</span><span class="s1"> 
            builder.keyPairGenerator) </span><span class="s2">// A generator that defines which function is used to generate DH key pair</span><span class="s1"> 
 
    companion </span><span class="s0">object </span><span class="s1">{ 
        inline </span><span class="s0">fun </span><span class="s1">build(appSpecificInfo: ByteArray, block: Builder.() -&gt; Unit) = Builder(appSpecificInfo).apply(block).build() 
    } 
 
    </span><span class="s0">class </span><span class="s1">Builder( 
            </span><span class="s0">val </span><span class="s1">appSpecificInfo: ByteArray 
    ) { 
        </span><span class="s0">val </span><span class="s1">maxSkip: Int = </span><span class="s4">10 </span><span class="s2">// 10 Max skipped messages by default</span><span class="s1"> 
        </span><span class="s0">val </span><span class="s1">cryptoEngine: BlockCipher = AESEngine() </span><span class="s2">// AES encryption by default</span><span class="s1"> 
        </span><span class="s0">val </span><span class="s1">AEADBlockCipher: AEADBlockCipher = GCMBlockCipher(cryptoEngine) </span><span class="s2">// GCM mode by default</span><span class="s1"> 
        </span><span class="s0">val </span><span class="s1">fixedNonce: ByteArray = byteArrayOf(</span><span class="s4">0x24</span><span class="s1">, </span><span class="s4">0x7b</span><span class="s1">, </span><span class="s4">0x67</span><span class="s1">, </span><span class="s4">0x10</span><span class="s1">, </span><span class="s4">0x19</span><span class="s1">, </span><span class="s4">0x75</span><span class="s1">, </span><span class="s4">0x65</span><span class="s1">, </span><span class="s4">0x41</span><span class="s1">, </span><span class="s4">0x10</span><span class="s1">, </span><span class="s4">0x2e</span><span class="s1">) </span><span class="s2">// A default nonce</span><span class="s1"> 
        </span><span class="s0">val </span><span class="s1">macSize: Int = </span><span class="s4">128 </span><span class="s2">// 128 bits long mac by default</span><span class="s1"> 
        </span><span class="s0">val </span><span class="s1">keyPairGenerator: DoubleRatchetKeyPairGenerator = DefaultKeyPairGenerator() </span><span class="s2">// Default generator using Curve25519</span><span class="s1"> 
 
        </span><span class="s0">fun </span><span class="s1">build() = DoubleRatchet(</span><span class="s0">this</span><span class="s1">) 
    } 
 
    </span><span class="s0">fun </span><span class="s1">createInitiatorState(sharedKey: ByteArray, publicKey: ByteArray): DoubleRatchetState { 
        </span><span class="s0">val </span><span class="s1">keyPair = generateKeyPair() 
        </span><span class="s0">val </span><span class="s1">kdfRootKey = kdfRootKey(sharedKey, calculateAgreement(keyPair, publicKey)) 
        </span><span class="s0">return </span><span class="s1">DoubleRatchetState(keyPair, publicKey, kdfRootKey.first, kdfRootKey.second, </span><span class="s0">null</span><span class="s1">) 
    } 
 
    </span><span class="s0">fun </span><span class="s1">createReceiverState(keyPair: DoubleRatchetKeyPair, sharedKey: ByteArray): DoubleRatchetState = 
            DoubleRatchetState(keyPair, </span><span class="s0">null</span><span class="s1">, sharedKey, </span><span class="s0">null</span><span class="s1">, </span><span class="s0">null</span><span class="s1">) 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Performs one step in sending chain and encrypts plaintext.</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">state current user state</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">plaintext plaintext to encrypt</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">ad associated data for authenticated encryption</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@return </span><span class="s2">a packet object containing header and encrypted message</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    </span><span class="s0">fun </span><span class="s1">ratchetEncrypt(state: DoubleRatchetState, plaintext: String, ad: ByteArray): DoubleRatchetPacket { 
        </span><span class="s0">val </span><span class="s1">ckStep = kdfChainKey(state.sendingChainKey!!) 
        state.sendingChainKey = ckStep.first 
        </span><span class="s0">val </span><span class="s1">mk = ckStep.second 
        </span><span class="s0">val </span><span class="s1">header = DoubleRatchetHeader(state.keyPair.getPublicKey(), state.previousChainSize, state.messageNumberSendingChain) 
        state.messageNumberSendingChain += </span><span class="s4">1</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">DoubleRatchetPacket(header, encrypt(mk, plaintext.toByteArray(), ad + header.toByteArray())) 
    } 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Checks if the packet corresponds to a skipped message. If yes, message key is used from the</span><span class="s1"> 
     </span><span class="s2">* saved ones and message decrypted. If it is not a skipped message, a new DH ratchet step is</span><span class="s1"> 
     </span><span class="s2">* made and new sending and receiving chain are created. Then, a new key is derived inside the</span><span class="s1"> 
     </span><span class="s2">* receiving chain and the message is decrypted.</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">state current user state</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">plaintext packet containing header and encrypted data</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">ad associated data for authenticated encryption</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@return </span><span class="s2">a byte array representing decrypted message</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    </span><span class="s0">fun </span><span class="s1">ratchetDecrypt(state: DoubleRatchetState, packet: DoubleRatchetPacket, ad: ByteArray): ByteArray { 
        </span><span class="s0">val </span><span class="s1">plainText = trySkippedMessageKeys(state, packet, ad) 
        </span><span class="s0">if </span><span class="s1">(plainText != </span><span class="s0">null</span><span class="s1">) 
            </span><span class="s0">return </span><span class="s1">plainText 
 
        </span><span class="s0">val </span><span class="s1">header = packet.header 
        </span><span class="s0">val </span><span class="s1">userDHr = state.receivedPublicKey 
        </span><span class="s0">if </span><span class="s1">((userDHr == </span><span class="s0">null</span><span class="s1">) || !header.publicKey.contentEquals(userDHr)) { 
            skipMessageKeys(state, header.previousChainSize) 
            DHRatchet(state, packet.header) 
        } 
 
        skipMessageKeys(state, header.messageNumber) 
        </span><span class="s0">val </span><span class="s1">kdfCk = kdfChainKey(state.receivingChainKey!!) 
        state.receivingChainKey = kdfCk.first 
        </span><span class="s0">val </span><span class="s1">mk = kdfCk.second 
        state.messageNumberReceivingChain += </span><span class="s4">1</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">decrypt(mk, packet.body, ad + header.toByteArray()) 
    } 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Generate a new DH key pair using Curve25519 by default as recommended in Double Ratchet</span><span class="s1"> 
     </span><span class="s2">* documentation.</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@return </span><span class="s2">A public-private key pair using Curve25519</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    </span><span class="s0">fun </span><span class="s1">generateKeyPair() = keyPairGenerator.generateKeyPair() 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Checks if there is a message key inside the array of skipped message keys for our packet.</span><span class="s1"> 
     </span><span class="s2">* If yes, returns it.</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@return </span><span class="s2">skipped message key or null if there is not such message key</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    private </span><span class="s0">fun </span><span class="s1">trySkippedMessageKeys(state: DoubleRatchetState, packet: DoubleRatchetPacket, ad: ByteArray): ByteArray? { 
        </span><span class="s0">val </span><span class="s1">mk = state.skippedMessageKeys.get(packet.header.publicKey, packet.header.messageNumber) 
        </span><span class="s0">if </span><span class="s1">(mk != </span><span class="s0">null</span><span class="s1">) { 
            state.skippedMessageKeys.remove(packet.header.publicKey, packet.header.messageNumber) 
            </span><span class="s0">return </span><span class="s1">decrypt(mk, packet.body, ad + packet.header.toByteArray()) 
        } </span><span class="s0">else </span><span class="s1">{ 
            </span><span class="s0">return null</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Checks if number of skipped messages didn't exceed max. If yes, throws an exception. If not,</span><span class="s1"> 
     </span><span class="s2">* creates skipped message keys in the stack.</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">state current state containing reciving chain</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">until sending chain size from header of the received message</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    private </span><span class="s0">fun </span><span class="s1">skipMessageKeys(state: DoubleRatchetState, until: Int) { 
        </span><span class="s0">if </span><span class="s1">(state.messageNumberReceivingChain + maxSkip &lt; until) { 
            </span><span class="s0">throw </span><span class="s1">IllegalStateException(</span><span class="s5">&quot;MAX_SKIP exceeded&quot;</span><span class="s1">) 
        } 
        </span><span class="s0">val </span><span class="s1">CKr = state.receivingChainKey 
        </span><span class="s0">if </span><span class="s1">(CKr != </span><span class="s0">null</span><span class="s1">) { 
            </span><span class="s0">while </span><span class="s1">(state.messageNumberReceivingChain &lt; until) { 
                </span><span class="s0">val </span><span class="s1">kdf = kdfChainKey(CKr) 
                state.receivingChainKey = kdf.first 
                state.skippedMessageKeys.put(state.receivedPublicKey!!, state.messageNumberReceivingChain, kdf.second) 
                state.messageNumberReceivingChain += </span><span class="s4">1</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Performs a new DH ratchet step.</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">state current [DoubleRatchetState] object on which we perform DH ratchet step</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">header header of the received message that contains public key for DH</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    private </span><span class="s0">fun </span><span class="s1">DHRatchet(state: DoubleRatchetState, header: DoubleRatchetHeader) { 
        state.previousChainSize = state.messageNumberSendingChain 
        state.messageNumberSendingChain = </span><span class="s4">0</span><span class="s1"> 
        state.messageNumberReceivingChain = </span><span class="s4">0</span><span class="s1"> 
        state.receivedPublicKey = header.publicKey 
        </span><span class="s0">val </span><span class="s1">kdfRk = kdfRootKey(state.rootKey, calculateAgreement(state.keyPair, state.receivedPublicKey!!)) 
        state.rootKey = kdfRk.first 
        state.receivingChainKey = kdfRk.second 
        state.keyPair = generateKeyPair() 
        </span><span class="s0">val </span><span class="s1">kdfRk2 = kdfRootKey(state.rootKey, calculateAgreement(state.keyPair, state.receivedPublicKey!!)) 
        state.rootKey = kdfRk2.first 
        state.sendingChainKey = kdfRk2.second 
    } 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Returns shared secret key for our key pair and received public key</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    private </span><span class="s0">fun </span><span class="s1">calculateAgreement(keyPair: DoubleRatchetKeyPair, publicKey: ByteArray) 
            = keyPair.getAgreement(publicKey) 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* KDF function used for the root chain based on HKDF and SHA512 as recommended in documentation</span><span class="s1"> 
     </span><span class="s2">* of Double Ratchet</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">rk current root key</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">dhOut output of DH ratchet step</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@return </span><span class="s2">pair of 32 byte long new root key and 32 byte long new chain key</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    private </span><span class="s0">fun </span><span class="s1">kdfRootKey(rk: ByteArray, dhOut: ByteArray): Pair&lt;ByteArray, ByteArray&gt; { 
        </span><span class="s0">val </span><span class="s1">hkdfParameters = HKDFParameters(dhOut, rk, appSpecificInfo) 
        </span><span class="s0">val </span><span class="s1">out = ByteArray(</span><span class="s4">64</span><span class="s1">) 
        </span><span class="s0">val </span><span class="s1">hkdfGenerator = HKDFBytesGenerator(SHA512Digest()) 
        hkdfGenerator.init(hkdfParameters) 
        hkdfGenerator.generateBytes(out, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">64</span><span class="s1">) 
        </span><span class="s0">val </span><span class="s1">newRk = out.take(</span><span class="s4">32</span><span class="s1">) 
        </span><span class="s0">val </span><span class="s1">newCk = out.takeLast(</span><span class="s4">32</span><span class="s1">) 
        </span><span class="s0">return </span><span class="s1">Pair(newRk.toByteArray(), newCk.toByteArray()) 
    } 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* KDF function used for the sending and the receiving chains based on HMAC and SHA512</span><span class="s1"> 
     </span><span class="s2">* as recommended in documentation of Double Ratchet</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@param </span><span class="s2">ck current chain key</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@return </span><span class="s2">pair of 32 byte long new chain key and 32 byte long new message key</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    private </span><span class="s0">fun </span><span class="s1">kdfChainKey(ck: ByteArray): Pair&lt;ByteArray, ByteArray&gt; { 
        </span><span class="s0">val </span><span class="s1">param = KeyParameter(ck) 
        </span><span class="s0">val </span><span class="s1">hmacGenerator = HMac(SHA512Digest()) 
        hmacGenerator.init(param) 
        </span><span class="s0">val </span><span class="s1">buff = ByteArray(</span><span class="s4">64</span><span class="s1">) 
        hmacGenerator.doFinal(buff, </span><span class="s4">0</span><span class="s1">) 
        </span><span class="s0">val </span><span class="s1">newCk = buff.take(</span><span class="s4">32</span><span class="s1">) 
        </span><span class="s0">val </span><span class="s1">newMk = buff.takeLast(</span><span class="s4">32</span><span class="s1">) 
        </span><span class="s0">return </span><span class="s1">Pair(newCk.toByteArray(), newMk.toByteArray()) 
    } 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Encrypts data using AES encryption in GCM mode of operation. AEAD accepts message key,</span><span class="s1"> 
     </span><span class="s2">* plaintext and some associated data used for authentication.</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@return </span><span class="s2">encrypted data</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    private </span><span class="s0">fun </span><span class="s1">encrypt(mk: ByteArray, plainText: ByteArray, associatedData: ByteArray?): ByteArray { 
        </span><span class="s0">val </span><span class="s1">params = AEADParameters(KeyParameter(mk), macSize, fixedNonce, associatedData) 
        AEADBlockCipher.init(</span><span class="s0">true</span><span class="s1">, params) 
        </span><span class="s0">val </span><span class="s1">outBuff = ByteArray(AEADBlockCipher.getOutputSize(plainText.size)) 
        </span><span class="s0">val </span><span class="s1">offset = AEADBlockCipher.processBytes(plainText, </span><span class="s4">0</span><span class="s1">, plainText.size, outBuff, </span><span class="s4">0</span><span class="s1">) 
        AEADBlockCipher.doFinal(outBuff, offset) 
        </span><span class="s0">return </span><span class="s1">outBuff 
    } 
 
    </span><span class="s2">/**</span><span class="s1"> 
     </span><span class="s2">* Decrypts data using the same algorithms as for encryption. See [encrypt].</span><span class="s1"> 
     </span><span class="s2">*</span><span class="s1"> 
     </span><span class="s2">* </span><span class="s3">@return </span><span class="s2">decrypted data</span><span class="s1"> 
     </span><span class="s2">*/</span><span class="s1"> 
    private </span><span class="s0">fun </span><span class="s1">decrypt(mk: ByteArray, cypherText: ByteArray, associatedData: ByteArray?): ByteArray { 
        </span><span class="s0">val </span><span class="s1">params = AEADParameters(KeyParameter(mk), macSize, fixedNonce, associatedData) 
        AEADBlockCipher.init(</span><span class="s0">false</span><span class="s1">, params) 
        </span><span class="s0">val </span><span class="s1">outBuff = ByteArray(AEADBlockCipher.getOutputSize(cypherText.size)) 
        </span><span class="s0">val </span><span class="s1">offset = AEADBlockCipher.processBytes(cypherText, </span><span class="s4">0</span><span class="s1">, cypherText.size, outBuff, </span><span class="s4">0</span><span class="s1">) 
        AEADBlockCipher.doFinal(outBuff, offset) 
        </span><span class="s0">return </span><span class="s1">outBuff 
    } 
 
}</span></pre>
</body>
</html>